"""
hilbert_substrate_core.py

Hilbert-space-first substrate engine.

- Ontology: a single Hilbert space H = ⊗_i H_i and a global pure state |Ψ>.
- Locality: time evolution generated by a sequence of local unitaries acting on small
  subsets of factors (no explicit lattice or geometry).
- No-forgetting: global evolution is strictly unitary.
- Tools: reduced density matrices, single-factor coherence diagnostics,
  and NPZ-based save/load for reproducibility.

This module is deliberately minimal. Higher-level experiments (pointer basis demos,
Lieb–Robinson diagnostics, exchange statistics, emergent geometry, etc.) should be
implemented in separate scripts that import this core.
"""

from __future__ import annotations

from dataclasses import dataclass, asdict
from typing import List, Sequence, Tuple, Optional, Union, NamedTuple, Dict, Any

import numpy as np

try:
    import cupy as cp  # type: ignore
except Exception:  # pragma: no cover - optional dependency
    cp = None


ArrayLike = Union[np.ndarray, "cp.ndarray"]


# ---------------------------------------------------------------------------
# Configuration
# ---------------------------------------------------------------------------

@dataclass
class Config:
    """
    Configuration for the Hilbert substrate.

    Attributes
    ----------
    n_factors : int
        Number of tensor factors in the global Hilbert space.
        Total dimension is local_dim ** n_factors.
    local_dim : int
        Dimension of each local factor Hilbert space. Default is 2 (qubits),
        but higher dimensions are allowed.
    use_gpu : bool
        If True and CuPy is available, state vectors and operations are stored
        on GPU. Otherwise, NumPy CPU backend is used.
    seed : Optional[int]
        Seed for initializing the global state. If None, NumPy's default RNG
        seed is used.
    product_state : Optional[Sequence[int]]
        Optional specification of an initial product state in the computational
        basis. If provided, it should be a sequence of length n_factors whose
        entries are integers in [0, local_dim-1]. If None, a random pure state
        is used.
    """

    n_factors: int
    local_dim: int = 2
    use_gpu: bool = False
    seed: Optional[int] = None
    product_state: Optional[Sequence[int]] = None

    def to_dict(self) -> Dict[str, Any]:
        """Return a JSON/NPZ-serializable dict representation."""
        return asdict(self)

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "Config":
        """Reconstruct a Config from a dict produced by to_dict()."""
        return Config(
            n_factors=int(d["n_factors"]),
            local_dim=int(d["local_dim"]),
            use_gpu=bool(d["use_gpu"]),
            seed=None if d["seed"] is None else int(d["seed"]),
            product_state=None if d["product_state"] is None else list(d["product_state"]),
        )


# ---------------------------------------------------------------------------
# Local terms
# ---------------------------------------------------------------------------

class LocalTerm(NamedTuple):
    """
    A local unitary term acting on a subset of tensor factors.

    Attributes
    ----------
    sites : Tuple[int, ...]
        Indices of the factors this unitary acts on. Must be distinct integers
        in [0, n_factors-1]. The order is irrelevant; the implementation
        internally sorts them.
    unitary : ArrayLike
        A square unitary array of shape (d**k, d**k), where d is local_dim and
        k = len(sites). The unitary should be defined in the standard tensor
        product ordering of those k local spaces.
    """

    sites: Tuple[int, ...]
    unitary: ArrayLike


# ---------------------------------------------------------------------------
# Substrate core
# ---------------------------------------------------------------------------

class Substrate:
    """
    Hilbert-space substrate with local-unitary dynamics.

    This class stores:
        - a Config,
        - a global pure state |Ψ>,
        - a list of local unitary terms representing the microscopic dynamics.

    Time evolution is implemented as a discrete-time circuit:
        |Ψ(t+Δt)> = (∏_α U_α) |Ψ(t)>

    where each U_α is a LocalTerm acting on a small subset of factors.
    """

    def __init__(self, cfg: Config):
        self.cfg = cfg

        # Select backend
        self.xp = self._select_backend(cfg.use_gpu)

        # Internal state vector |Ψ> as a 1D complex array of length d**N
        self.state: ArrayLike = self._init_state()

        # List of LocalTerm instances defining the dynamics
        self.local_terms: List[LocalTerm] = []

    # ------------------------------ Backend ---------------------------------

    @staticmethod
    def _select_backend(use_gpu: bool):
        """
        Choose the array module (NumPy or CuPy) based on the use_gpu flag and
        availability of CuPy.
        """
        if use_gpu and cp is not None:
            return cp
        return np

    @property
    def on_gpu(self) -> bool:
        """Return True if the current backend is CuPy (GPU)."""
        return self.xp is not np

    def to_numpy(self, arr: ArrayLike) -> np.ndarray:
        """Convert a backend array (NumPy or CuPy) to a NumPy array."""
        if isinstance(arr, np.ndarray):
            return arr
        if cp is not None and isinstance(arr, cp.ndarray):  # type: ignore
            return cp.asnumpy(arr)  # type: ignore
        # Fallback: assume it's array-like
        return np.asarray(arr)

    # --------------------------- State handling ------------------------------

    def _init_state(self) -> ArrayLike:
        """
        Initialize the global state |Ψ>.

        - If cfg.product_state is provided, prepare the corresponding
          computational-basis product state.
        - Otherwise, draw a random complex vector and normalize it.
        """
        n = self.cfg.n_factors
        d = self.cfg.local_dim
        dim_total = d ** n

        if self.cfg.product_state is not None:
            if len(self.cfg.product_state) != n:
                raise ValueError(
                    f"product_state length {len(self.cfg.product_state)} != n_factors {n}"
                )
            for idx in self.cfg.product_state:
                if not (0 <= idx < d):
                    raise ValueError(
                        f"Invalid local index {idx} in product_state; must be in [0, {d-1}]"
                    )

            # Map product_state to a basis index in [0, d**n - 1]
            basis_index = 0
            for i, val in enumerate(self.cfg.product_state):
                basis_index *= d
                basis_index += val

            psi = np.zeros(dim_total, dtype=np.complex128)
            psi[basis_index] = 1.0 + 0.0j

        else:
            rng = np.random.default_rng(self.cfg.seed)
            real = rng.normal(size=dim_total)
            imag = rng.normal(size=dim_total)
            psi = real + 1j * imag
            norm = np.linalg.norm(psi)
            if norm == 0.0:
                raise RuntimeError("Random initialization produced zero-norm state.")
            psi /= norm

        # Move to backend
        return self.xp.asarray(psi)

    @property
    def dim_total(self) -> int:
        """Total Hilbert-space dimension d**N."""
        return self.cfg.local_dim ** self.cfg.n_factors

    def norm(self) -> float:
        """Return the global norm ||Ψ|| (should always be ~1)."""
        xp = self.xp
        val = xp.linalg.norm(self.state)
        return float(self.to_numpy(val))

    # --------------------------- Local unitaries -----------------------------

    def add_local_unitary(self, sites: Sequence[int], unitary: ArrayLike) -> None:
        """
        Register a local unitary term.

        Parameters
        ----------
        sites : Sequence[int]
            Indices of factors the unitary acts on. Must be distinct integers
            in [0, n_factors-1].
        unitary : ArrayLike
            Square array of shape (d**k, d**k), where d=local_dim and
            k=len(sites). Should be unitary, but this is not enforced here.
        """
        n = self.cfg.n_factors
        d = self.cfg.local_dim

        sites_tuple = tuple(sorted(int(s) for s in sites))
        if len(sites_tuple) == 0:
            raise ValueError("Local term must act on at least one factor.")
        if len(set(sites_tuple)) != len(sites_tuple):
            raise ValueError(f"Duplicate factor indices in sites={sites_tuple}.")
        for s in sites_tuple:
            if not (0 <= s < n):
                raise ValueError(
                    f"Site index {s} out of range [0, {n-1}] for n_factors={n}."
                )

        unitary_np = self.to_numpy(unitary)
        k = len(sites_tuple)
        expected_dim = d ** k
        if unitary_np.shape != (expected_dim, expected_dim):
            raise ValueError(
                f"Local unitary shape {unitary_np.shape} incompatible with "
                f"local_dim={d} and len(sites)={k}; expected ({expected_dim}, {expected_dim})."
            )

        # Move to backend
        U_backend = self.xp.asarray(unitary_np)
        self.local_terms.append(LocalTerm(sites=sites_tuple, unitary=U_backend))

    @staticmethod
    def hermitian_to_unitary(
        H: np.ndarray,
        dt: float,
        use_gpu: bool = False,
    ) -> ArrayLike:
        """
        Construct a unitary U = exp(-i H dt) from a small Hermitian H.

        This is intended for small local Hilbert spaces (e.g., 2x2, 4x4, 8x8).
        For larger matrices this will be slow.

        Parameters
        ----------
        H : np.ndarray
            Hermitian matrix of shape (m, m).
        dt : float
            Time step.
        use_gpu : bool
            If True and CuPy is available, return a CuPy array.

        Returns
        -------
        U : ArrayLike
            The unitary exp(-i H dt).
        """
        H = np.asarray(H, dtype=np.complex128)
        if H.shape[0] != H.shape[1]:
            raise ValueError("H must be square.")
        # Diagonalize H = V diag(λ) V†, then exp(-iHdt) = V diag(e^{-iλdt}) V†
        evals, evecs = np.linalg.eigh(H)
        phases = np.exp(-1j * dt * evals)
        U = (evecs * phases) @ evecs.conj().T

        if use_gpu and cp is not None:
            return cp.asarray(U)  # type: ignore
        return U

    # ----------------------------- Time evolution ----------------------------

    def step(self, n_steps: int = 1) -> None:
        """
        Apply one or more discrete time steps of the local-unitary circuit.

        Each step applies all registered local terms in the order they were
        added:
            |Ψ> ← U_M ... U_2 U_1 |Ψ>

        Parameters
        ----------
        n_steps : int
            Number of time steps to apply.
        """
        if n_steps < 1:
            return
        if not self.local_terms:
            # No dynamics defined; nothing to do.
            return

        for _ in range(n_steps):
            for term in self.local_terms:
                self._apply_local_unitary(term)

    def _apply_local_unitary(self, term: LocalTerm) -> None:
        """
        Apply a local unitary term to the global state |Ψ>.

        Implementation detail: we reshape |Ψ> to a tensor of shape
            (d, d, ..., d) with n_factors axes,
        permute axes so that the target sites come last, apply the unitary
        to the last k indices, and finally unpermute.
        """
        xp = self.xp
        d = self.cfg.local_dim
        n = self.cfg.n_factors

        sites = list(term.sites)
        k = len(sites)
        if k == 0:
            return

        # Reshape state to rank-n tensor
        psi = self.state.reshape((d,) * n)

        # Permutation: all non-target axes first, then target axes
        non_sites = [i for i in range(n) if i not in sites]
        perm = non_sites + sites
        psi_perm = xp.transpose(psi, axes=perm)

        # Collapse to (rest_dim, d**k)
        rest_dim = d ** len(non_sites)
        local_dim = d ** k
        psi_flat = psi_perm.reshape(rest_dim, local_dim)

        # Apply local unitary on the local index
        # We want: psi'_r,a = Σ_b psi_r,b U_{a,b}
        # which corresponds to matrix multiplication psi_flat @ U.T
        U = term.unitary
        psi_flat = psi_flat @ U.T

        # Reshape back and invert permutation
        psi_perm = psi_flat.reshape((d,) * n)

        # Inverse permutation
        inv_perm = [0] * n
        for i, p in enumerate(perm):
            inv_perm[p] = i
        psi_new = xp.transpose(psi_perm, axes=inv_perm)

        self.state = psi_new.reshape(-1)

    # --------------------------- Reduced density ------------------------------

    def reduced_density(self, subsystem: Sequence[int]) -> np.ndarray:
        """
        Compute the reduced density matrix ρ_subsystem for a given set of factors.

        Parameters
        ----------
        subsystem : Sequence[int]
            Indices of factors to keep. All other factors are traced out.

        Returns
        -------
        rho : np.ndarray
            The reduced density matrix as a NumPy array of shape
            (d**k, d**k), where k=len(subsystem) and d=local_dim.
        """
        xp = self.xp
        n = self.cfg.n_factors
        d = self.cfg.local_dim

        if len(subsystem) == 0:
            raise ValueError("Subsystem must contain at least one factor index.")

        sub = sorted(int(i) for i in subsystem)
        if len(set(sub)) != len(sub):
            raise ValueError(f"Duplicate indices in subsystem={sub}.")
        for i in sub:
            if not (0 <= i < n):
                raise ValueError(
                    f"Subsystem index {i} out of range [0, {n-1}] for n_factors={n}."
                )

        env = [i for i in range(n) if i not in sub]

        psi = self.state.reshape((d,) * n)
        perm = sub + env
        psi_perm = xp.transpose(psi, axes=perm)

        dim_sys = d ** len(sub)
        dim_env = d ** len(env)

        psi_flat = psi_perm.reshape(dim_sys, dim_env)

        # ρ = ψ ψ† traced over env indices
        rho_backend = psi_flat @ xp.conjugate(psi_flat).T

        # Move to CPU for analysis
        return self.to_numpy(rho_backend)

    def single_factor_coherence(self, index: int) -> float:
        """
        Compute |ρ_01| (off-diagonal coherence) for a single factor,
        assuming local_dim == 2.

        Parameters
        ----------
        index : int
            Index of the factor whose reduced density matrix is considered.

        Returns
        -------
        coherence : float
            Absolute value |ρ_01| of the off-diagonal element.
        """
        if self.cfg.local_dim != 2:
            raise ValueError(
                "single_factor_coherence is defined only for local_dim == 2."
            )
        rho = self.reduced_density([index])
        if rho.shape != (2, 2):
            raise RuntimeError(
                f"Unexpected reduced density shape {rho.shape} for local_dim=2."
            )
        return float(np.abs(rho[0, 1]))

    # ------------------------------- I/O -------------------------------------

    def save_npz(self, path: str) -> None:
        """
        Save the substrate state and configuration to an NPZ file.

        Parameters
        ----------
        path : str
            Path to the output .npz file.
        """
        state_cpu = self.to_numpy(self.state)
        cfg_dict = self.cfg.to_dict()
        # It's easier to store cfg_dict as a numpy object array or via np.savez
        np.savez_compressed(path, state=state_cpu, cfg=cfg_dict)

    @classmethod
    def load_npz(cls, path: str, force_gpu: Optional[bool] = None) -> "Substrate":
        """
        Load a substrate state and configuration from an NPZ file created
        by save_npz().

        Parameters
        ----------
        path : str
            Path to the input .npz file.
        force_gpu : Optional[bool]
            If not None, overrides the use_gpu flag loaded from the file.

        Returns
        -------
        sub : Substrate
            A new Substrate instance with the loaded state and configuration.
        """
        data = np.load(path, allow_pickle=True)
        state_cpu: np.ndarray = data["state"]
        cfg_dict = data["cfg"].item()
        cfg = Config.from_dict(cfg_dict)
        if force_gpu is not None:
            cfg.use_gpu = bool(force_gpu)

        sub = cls(cfg)
        xp = sub.xp
        sub.state = xp.asarray(state_cpu)
        return sub

    # ------------------------- Lieb–Robinson hooks ---------------------------

    def interaction_graph(self) -> Dict[int, List[int]]:
        """
        Construct an interaction graph over factor indices based on current
        local terms.

        Returns
        -------
        graph : Dict[int, List[int]]
            A dictionary mapping each factor index i to a list of factor
            indices j that appear in at least one local term with i.

        Notes
        -----
        This does not assume any embedding in a geometric space; it simply
        encodes which factors can directly interact via the given local terms.
        """
        n = self.cfg.n_factors
        neighbors: Dict[int, List[int]] = {i: [] for i in range(n)}
        for term in self.local_terms:
            sites = list(term.sites)
            for i in sites:
                for j in sites:
                    if i == j:
                        continue
                    if j not in neighbors[i]:
                        neighbors[i].append(j)
        return neighbors

    def abstract_distance(self, i: int, j: int) -> Optional[int]:
        """
        Compute an abstract interaction distance between factor i and j
        as the shortest path length in the interaction graph defined by
        local terms.

        Parameters
        ----------
        i, j : int
            Factor indices.

        Returns
        -------
        dist : Optional[int]
            The length of the shortest path between i and j in the
            interaction graph, or None if j is not reachable from i.

        Notes
        -----
        This is *not* a physical distance in space. It is a purely
        graph-theoretic measure of how many local interaction "hops"
        separate two factors. It is meant as a hook for later Lieb–Robinson
        diagnostics implemented in higher-level analysis scripts.
        """
        n = self.cfg.n_factors
        if not (0 <= i < n and 0 <= j < n):
            raise ValueError(
                f"indices i={i}, j={j} must lie in [0, {n-1}] for n_factors={n}."
            )
        if i == j:
            return 0

        graph = self.interaction_graph()
        from collections import deque

        visited = set([i])
        queue = deque([(i, 0)])

        while queue:
            node, dist = queue.popleft()
            for nbr in graph[node]:
                if nbr == j:
                    return dist + 1
                if nbr not in visited:
                    visited.add(nbr)
                    queue.append((nbr, dist + 1))
        return None


# ---------------------------------------------------------------------------
# Minimal self-test (optional)
# ---------------------------------------------------------------------------

if __name__ == "__main__":
    # Simple smoke test: 2-qubit system with a single CZ gate.
    cfg = Config(n_factors=2, local_dim=2, use_gpu=False, product_state=[0, 0])
    sub = Substrate(cfg)

    # Pauli-Z-based controlled phase on |11>: diag(1, 1, 1, -1)
    CZ = np.diag([1.0, 1.0, 1.0, -1.0]).astype(np.complex128)
    sub.add_local_unitary(sites=[0, 1], unitary=CZ)

    print("Initial norm:", sub.norm())
    sub.step(n_steps=1)
    print("Post-step norm:", sub.norm())

    rho0 = sub.reduced_density([0])
    rho1 = sub.reduced_density([1])
    print("Reduced ρ_0:\n", rho0)
    print("Reduced ρ_1:\n", rho1)

    print("Interaction graph:", sub.interaction_graph())
    print("Abstract distance 0↔1:", sub.abstract_distance(0, 1))
